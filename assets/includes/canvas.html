<head>
    <style>
        #obsidian #fileread #canvas {
            --canvas-backdrop: rgba(200, 200, 200, 0.1);
            position: absolute;
            height: 10000px;
            width: 10000px;
            /* https://codepen.io/mapsandapps/pen/pbzooY */
            background-color: var(--bg);
            background-image: radial-gradient(rgb(108, 110, 112) 5%, transparent 0);
            background-size: 24px 24px;
        }

        #obsidian #fileread #canvas #canvas-content {
            width: 100%;
            height: 100%;
            transform-origin: center center;
        }

        #obsidian #fileread #canvas .card {
            box-sizing: border-box;
            padding: .8rem;
            padding-bottom: 0;
            border-radius: .5rem;
            border: 1px solid var(--color-border);
            overflow: auto;
        }

        #obsidian #fileread #canvas .card.text,
        #obsidian #fileread #canvas .card.file {
            background-color: var(--bg);
        }

        #obsidian #fileread #canvas .card.group {
            background-color: var(--canvas-backdrop);
        }
    </style>
</head>

<body>
    <div id="canvas-content"></div>
</body>


<script>
    function loadCanvas(canvasPath) {
        const fullFilePath = getFullFilePath(canvasPath);
        generateBreadcrumbs(canvasPath);
        console.log("fullFilePath Canvas: " + fullFilePath)

        fetch(fullFilePath).then(response => {
            if (!response.ok)
                throw new Error('Network response: ' + response.statusText);
            return response.text();
        }).then(content => {
            try {
                FILEREAD.scrollTop = 0;
                FILEREAD.scrollLeft = 0;
                const canvas_parsed = JSON.parse(content);
                if (!canvas_parsed.nodes || !Array.isArray(canvas_parsed.nodes)) {
                    console.error('Invalid or missing nodes array');
                    return;
                }

                const canvasContent = CANVAS.querySelector('#canvas-content');
                while (canvasContent.firstChild)
                    canvasContent.removeChild(canvasContent.firstChild);
                canvasContent.style.transform = `scale(1)`;

                const keysList = canvas_parsed.nodes.map(node => Object.keys(node));
                console.log("Canvas keysList: " + keysList);

                const canvasWidth = window.getComputedStyle(CANVAS).width;
                console.warn("Canvas width: " + canvasWidth);
                const canvasSizeHalved = parseInt(canvasWidth) / 2;

                const minX = canvas_parsed.nodes.reduce((min, node) => Math.min(min, node.x), Infinity);
                const maxX = canvas_parsed.nodes.reduce((max, node) => Math.max(max, node.x), -Infinity);
                const minY = canvas_parsed.nodes.reduce((min, node) => Math.min(min, node.y), Infinity);
                const maxY = canvas_parsed.nodes.reduce((max, node) => Math.max(max, node.y), -Infinity);

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                console.warn(`Center point: (${centerX}, ${centerY})`);

                console.log(`minX: ${minX}, maxX: ${maxX}, minY: ${minY}, maxY: ${maxY}`);
                canvas_parsed.nodes.forEach(node => {
                    console.log(`id: ${node.id}, type: ${node.type},x: ${node.x}, y: ${node.y}`);
                    const card = document.createElement('div');
                    switch (node.type) {
                        case "text":
                        default:
                            card.classList.add('card', 'text');
                            if (node.text) {
                                const cardDiv = parseStringToMarkdown(node.text);
                                card.innerHTML = DOMPurify.sanitize(cardDiv.innerHTML);
                                cardDiv.remove();
                                if (BACKLINKS_JSON) mapBacklinksToJson(BACKLINKS_JSON);
                            }
                            break;
                        case "file":
                            card.classList.add('card', 'file');
                            card.textContent = node.file;
                            break;
                        case "link":
                            card.classList.add('card', 'link');
                            card.textContent = node.link;
                            break;
                        case "group":
                            card.classList.add('card', 'group');
                            // card.textContent = node.label;
                            break;
                    }
                    // Set the div's position and size
                    card.style.position = 'absolute';
                    card.style.left = `${node.x + (-minX) + canvasSizeHalved}px`;
                    card.style.top = `${node.y + (-minY) + canvasSizeHalved}px`;
                    card.style.width = `${node.width}px`;
                    card.style.height = `${node.height}px`;

                    canvasContent.appendChild(card);
                });

                const boundingBox = getBoundingBoxOfChildren(canvasContent);
                if (boundingBox) {
                    const center = getCenterOfBoundingBox(boundingBox);
                    console.info(`Bounding box height: ${boundingBox.height}, width: ${boundingBox.width}`);
                    console.info(`Canvas center: x=${center.x}, y=${center.y}`);
                    const FILEREADWidth = FILEREAD.offsetWidth;
                    const FILEREADHeight = FILEREAD.offsetHeight;

                    console.log(`FILEREAD Width: ${FILEREADWidth}px`);
                    console.log(`FILEREAD Height: ${FILEREADHeight}px`);
                    FILEREAD.scrollTop = center.y;
                    FILEREAD.scrollLeft = center.x;

                    canvasContent.querySelectorAll('.card').forEach(card => {
                        const newLeft = card.offsetLeft + boundingBox.width / 2;
                        card.style.left = `${newLeft}px`;
                    });
                } else
                    console.warn('The parent element has no children.');

                FILEREAD.addEventListener('wheel', adjustCanvasScaleOnScroll);
                console.warn("wheel event listener added to FILEREAD");
            } catch (e) {
                console.error("Error parsing canvas:", e);
            }
        });
    }
</script>
<!-- --------------------- Canvas movement and zooming --------------------- -->
<script>
    function getBoundingBoxOfChildren(parentElement) {
        const children = parentElement.children;
        if (children.length === 0) {
            return null;
        }

        // Initialize the bounding box with the first child's bounding rectangle
        const firstChildRect = children[0].getBoundingClientRect();
        let minX = firstChildRect.left;
        let minY = firstChildRect.top;
        let maxX = firstChildRect.right;
        let maxY = firstChildRect.bottom;

        // Iterate over all children to find the bounding box
        for (let i = 1; i < children.length; i++) {
            const rect = children[i].getBoundingClientRect();
            if (rect.left < minX) minX = rect.left;
            if (rect.top < minY) minY = rect.top;
            if (rect.right > maxX) maxX = rect.right;
            if (rect.bottom > maxY) maxY = rect.bottom;
        }

        const boundingBox = {
            left: minX,
            top: minY,
            right: maxX,
            bottom: maxY,
            width: maxX - minX,
            height: maxY - minY,
        };

        return boundingBox;
    }

    // Function to calculate the center of the bounding box
    function getCenterOfBoundingBox(boundingBox) {
        const centerX = boundingBox.left + (boundingBox.width / 2);
        const centerY = boundingBox.top + (boundingBox.height / 2);
        return { x: centerX, y: centerY };
    }

    function adjustCanvasScaleOnScroll(e) {
        if (e.ctrlKey) {
            e.preventDefault();
            const canvasContent = CANVAS.querySelector('#canvas-content');
            let scale = parseFloat(canvasContent.style.transform.replace(/[^0-9.-]/g, ''));
            if (isNaN(scale)) scale = 1; // Default scale

            // Get cursor position relative to the FILEREAD element
            const rect = FILEREAD.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Store old scale to calculate the difference
            const oldScale = scale;

            // Update the scale
            console.info("Scroll direction: " + (e.deltaY > 0 ? "down" : "up"));
            if (e.deltaY > 0) {
                scale = Math.max(0.1, scale - 0.01); // Decrease scale
            } else {
                scale = Math.min(2, scale + 0.01); // Increase scale
            }

            // Apply the new scale
            canvasContent.style.transform = `scale(${scale})`;
            // Calculate the ratio of the scale change
            const scaleRatio = scale / oldScale;
            // Adjust scroll to maintain cursor position
            FILEREAD.scrollLeft = scaleRatio * (FILEREAD.scrollLeft + x) - x;
            FILEREAD.scrollTop = scaleRatio * (FILEREAD.scrollTop + y) - y;
        }
    }


</script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const homepage = '{{ site.obsidian_homepage | escape }}';
        if (homepage && homepage.endsWith('.canvas')) {
            loadCanvas(homepage);
            console.log("canvas read loaded: " + homepage);
        }
    });

    document.addEventListener('obsidian_canvasSelect', function (event) {
        switchPage(event.detail.filePath);
        loadCanvas(event.detail.filePath);
    });
</script>