<head>
    <style>
        #obsidian #fileread #note {
            padding-top: 0;
            padding-bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }

        #obsidian #fileread #note-title {
            font-size: 2em;
            font-weight: bold;
            margin: .2em 0 1rem 0;
        }

        #obsidian #fileread #note .backlink {
            color: var(--color-accent);
        }

        /* --------------------------- Linked mentions --------------------------- */
        #obsidian #fileread #note #linked-mentions {
            font-size: 1.2em;
            width: 100%;
            margin: 8rem 0 3rem 0;
            border-top: 1px solid var(--color-border);
        }

        #obsidian #fileread #note .backlink,
        #obsidian #fileread #note #linked-mentions .title {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
        }

        #obsidian #fileread #note #linked-mentions ul,
        #obsidian #fileread #note #linked-mentions .title {
            list-style: none;
            padding: 0;
            width: 100%;
            margin-left: 0px;
            padding-top: 4px;
            margin-bottom: 5px;
        }

        #obsidian #fileread #note #linked-mentions .title button {
            font-size: .85em;
            display: block;
            width: auto;
            text-align: left;
            padding: 5px 5px 5px 10px;
        }

        #obsidian #fileread #note #linked-mentions button:hover {
            background-color: var(--bg-linked-mention-highlight);
        }

        #obsidian #fileread #note #linked-mentions button ul li.sentence {
            color: var(--color-linked-mention-text);
            width: 96%;
            padding: 8px 5px;
            font-size: 1rem;
            line-height: 1.4rem;
        }

        #obsidian #fileread #note #linked-mentions ul button.sentence:first-child {
            border: 1px solid var(--color-border);
            border-top-left-radius: .6rem;
            border-top-right-radius: .6rem;
        }

        #obsidian #fileread #note #linked-mentions ul button.sentence:first-child:hover {
            border-top: 1px solid var(--color-border-dark);
        }

        #obsidian #fileread #note #linked-mentions ul button.sentence:not(:first-child),
        #obsidian #fileread #note #linked-mentions ul button.sentence:last-child:hover {
            border-bottom: 1px solid var(--color-border);
            border-left: 1px solid var(--color-border);
            border-right: 1px solid var(--color-border);
        }

        #obsidian #fileread #note #linked-mentions ul button.sentence:not(:first-child):hover,
        #obsidian #fileread #note #linked-mentions ul button.sentence:first-child:hover {
            border-left: 1px solid var(--color-border-dark);
            border-right: 1px solid var(--color-border-dark);
        }

        #obsidian #fileread #note #linked-mentions ul button.sentence:last-child {
            border-bottom-left-radius: .6rem;
            border-bottom-right-radius: .6rem;
        }
    </style>
</head>

<body>
    <h3 id="note-title"></h3>
    <div id="file-content"></div>
    <ul id="linked-mentions"></ul>
</body>

<script>
    function generateLinkedMentions(filePath, backlinks_parsed) {
        const vaultPath = '/' + '{{ site.obsidian_vault | escape }}' + '/';
        let linked_mentions = [];
        for (const parsedFilePath in backlinks_parsed) {
            const entry = backlinks_parsed[parsedFilePath];
            entry.backlink_paths.forEach(path => {
                if (path === filePath && parsedFilePath.endsWith('.md')) {
                    console.log("linked mention: " + parsedFilePath);
                    linked_mentions.push(parsedFilePath.replace("/:|", "'"));
                }
            });
        }
        // if (entry.backlink_paths && entry.backlink_paths.length > 0) {
        //     entry.backlink_paths.forEach(path => {
        //         // console.log("pathh " + path);
        //         if (!linked_mentions.includes(parsedFilePath) &&
        //             path === filePath &&
        //             parsedFilePath.endsWith('.md')) {
        //             console.log("linked mention: " + parsedFilePath);
        //             linked_mentions.push(parsedFilePath.replace("/:|", "'"));
        //         }
        //     });
        // }
        // }
        const linkedMentionsId =
            document.querySelector(`${css_fileread} #note #linked-mentions`);
        while (linkedMentionsId.firstChild)
            linkedMentionsId.removeChild(linkedMentionsId.firstChild);
        if (linked_mentions.length !== 0) {
            const h4 = document.createElement('h4');
            h4.textContent = 'Linked mentions';
            linkedMentionsId.appendChild(h4);
        }
        linked_mentions.forEach(linkedMentionPath => {
            const li = document.createElement('li');
            const linkedPathName = extractFilenameFromPath(linkedMentionPath);
            linkedMentionsId.appendChild(li);
            li.classList.add('title');
            const decodedString = he.decode(linkedPathName);
            li.textContent = decodedString;

            const linkedMentionPathFull = vaultPath + linkedMentionPath;
            fetch(linkedMentionPathFull)
                .then(response => {
                    if (!response.ok)
                        throw new Error('Network response: ' + response.statusText);
                    return response.text();
                }).then(content => {
                    const ul_linkedMention = document.createElement('ul');
                    li.appendChild(ul_linkedMention);
                    const backlink = `[[${extractFilenameFromPath(filePath)}]]`;
                    let lines = content.split('\n');
                    // let lines = content.split(/(?<=[.!?])\s*(?=\n|$)/);
                    console.log("lines: " + content);
                    lines.forEach(line => {
                        if (line) {
                            let stripped_line = line.toLowerCase().replace(/\|.*$/, '').replace(/#.*$/, '');
                            // console.log("line: " + stripped_line);
                            const line_backlinks = extractBacklinks(line);
                            if (line_backlinks) {
                                line_backlinks.forEach(line_backlink => {
                                    console.log("backlink line: " + line_backlink);
                                    const stripped_backlink = line_backlink.toLowerCase().replace(/\|.*?\]\]/, ']]').replace(/#.*?\]\]/, ']]');
                                    console.log("stripped_backlink: " + stripped_backlink);
                                    if (stripped_backlink === backlink.toLowerCase()) {
                                        const btnLinkedMention = document.createElement('button');
                                        btnLinkedMention.textContent = line;
                                        btnLinkedMention.classList.add('sentence');
                                        btnLinkedMention.dataset.filePath = linkedMentionPathFull;

                                        btnLinkedMention.addEventListener('click', function () {
                                            const filePath = this.dataset.filePath.replace(vaultPath, '');
                                            dispatchFileSelectEvt(filePath);
                                        });
                                        ul_linkedMention.appendChild(btnLinkedMention);
                                    }
                                });
                            }

                            // if (stripped_line.toLowerCase().includes(backlink.toLowerCase())) {
                            //     const btnLinkedMention = document.createElement('button');
                            //     btnLinkedMention.textContent = line;
                            //     btnLinkedMention.classList.add('sentence');
                            //     btnLinkedMention.dataset.filePath = linkedMentionPathFull;

                            //     btnLinkedMention.addEventListener('click', function () {
                            //         const filePath = this.dataset.filePath.replace(vaultPath, '');
                            //         dispatchFileSelectEvt(filePath);
                            //     });
                            //     ul_linkedMention.appendChild(btnLinkedMention);
                            // }
                        }
                    });
                }).catch(error => {
                    console.error('Error fetching file:', error);
                });
        });
    }
</script>

<script>
    function loadNote(filePath, header = "") {
        let enable_backlinks = '{{ site.obsidian_backlinks | escape }}';
        if (enable_backlinks === null ||
            enable_backlinks === '' ||
            enable_backlinks === undefined)
            enable_backlinks = "true";
        console.log("enable_backlinks: " + enable_backlinks);
        console.log("filePath: " + filePath);
        generateBreadcrumbs(filePath);
        fetchNoteContent(enable_backlinks, filePath, header);
    }

    function fetchNoteContent(backlinks_enabled, filePath, header = "") {
        const fullFilePath = getFullFilePath('/' + filePath);
        console.log("fullFilePath: " + fullFilePath)
        fetch(fullFilePath).then(response => {
            if (!response.ok)
                throw new Error('Network response: ' + response.statusText);
            return response.text();
        }).then(content => {
            const md = window.markdownit();
            let htmlContent = md.render(content);

            const cleanedHTML = document.createElement('div');
            cleanedHTML.innerHTML = DOMPurify.sanitize(htmlContent);

            const backlinksArr = extractBacklinks(content);
            if (backlinksArr) replaceBacklinks(backlinksArr, cleanedHTML);
            const calloutsArr = extractCallouts(content);
            if (calloutsArr) generateCallouts(calloutsArr, cleanedHTML);

            const embedsArr = extractEmbeds(content);
            if (embedsArr) generateEmbeds(embedsArr, cleanedHTML);

            const fileName = extractFilenameFromPath(filePath);
            document.querySelector(`${css_fileread} #note #note-title`).textContent =
                fileName;
            document.querySelector(`${css_fileread} #note #file-content`).innerHTML =
                cleanedHTML.innerHTML;
            document.querySelector(css_fileread).scrollTop = 0;
            if (header) {
                const headers = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
                headers.forEach((heading) => {
                    if (heading.textContent === header) {
                        heading.scrollIntoView();
                    }
                });
            }
            cleanedHTML.remove();

            if (backlinks_enabled === "true") {
                const backlinks = '{{ site.data.obsidian.backlinks | jsonify }}'
                try {
                    const backlinks_parsed = JSON.parse(backlinks);
                    mapBacklinksToJson(backlinks_parsed);
                    console.log("backlinks_parsed: " + backlinks_parsed);
                    generateLinkedMentions(filePath, backlinks_parsed);
                } catch (e) {
                    console.error("Error parsing backlinks:", e);
                }
            }
        }).catch(error => {
            console.error('Error fetching file:', error);
        });
    }
</script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const homepage = '{{ site.obsidian_homepage | escape }}'
        if (homepage && homepage.endsWith('.md')) {
            switchPage(homepage);
            loadNote(homepage);
            console.log("note loaded: " + homepage);
        }
    });

    document.addEventListener('obsidian_noteSelect', function (event) {
        switchPage(event.detail.filePath);
        loadNote(event.detail.filePath, event.detail.heading);
    });
</script>